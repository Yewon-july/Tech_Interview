### GoF 디자인 패턴

1. 생성 패턴
2. 구조 패턴
3. 행위 패턴



### 행위 패턴

- 반복적으로 사용되는 객체들의 상호작용을 패턴화한 것으로, 크랠스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의한다.

- 객체의 기능은 변하지 않지만 일을 처리하는 방법이 달라질 때가 있다. 응용 분야에 따라 행위가 다른 객체로 옮겨 가거나 알고리즘이 대체되는 경우이다. 이런 경우 대부분 상속 개념을 이용해 사용할 수 있다.

- 행위 패턴은 여러 가지 행위 관련 패턴을 사용하여 독립적으로 일을 처리하고자 할 때 사용한다.

  행위 퍁너은 메시지 교환과 관련된 것으로, 객체들 간의 행위나 알고리즘 등 관련된 패턴을 말한다.



### Iterator pattern

- **반복이 필요한 자료구조를 모두 동일한 인터페이스를 통해 접근** 할 수 있도록 iterator 객체 속에 넣은 다음, iterator 객체의 메서드를 이용해 자료구조를 활용할 수 있도록 해준다.
- 반복에 사용되는 구조에는 배열, 리스트, Set, Map 등이 있다.
- 이들의 특징은 어던 데이터의 집합체라는 것이다. 이 때 데이터들의 집합체를 모두 동일한 인터페이스로 사용하여 조작할 수 있게 하면 데이터들의 집합체를 쉽게 사용할 수 있을 것이다.



### Observer Pattern

- 어떤 클래스에 **변화가 일어났을 때, 이를 감지해서 다른 클래스에 통보** 해주는 것이다. ex) 값이 바뀌면 차트가 바뀜
- 어떤 일이 생기면 미리 등록한 객체들에게 상태 변화를 알려주는 역할을 한다.
- 1대 다의 객체 의존관계를 정의한 것으로 한 객체가 상태를 변화시켰을 때, 의존 관계에 있는 다른 객체들에게 자동적으로 통지하고 변경시킨다.



### Strategy Pattern

- 이 패턴을 사용하면 클라이언트와 무관하게 **독립적으로 알고리즘을 변경**할 수 있고, 클라이언트는 독립적으로 원하는 방식을 사용할 수 있다.
- 클라이언트에게 알고리즘이 사용하는 데이터나 그 구조를 **숨겨주는 역할**을 한다.
- 알고리즘을 **사용하는 곳과 알고리즘을 제공하는 곳을 분리**시킨 구조로 **알고리즘을 동적으로 교체**할 수 있다.



### Template Method Pattern

- 하나의 틀에서 만들어진 것들은 형태가 다 같다. 이런 틀 기능을 구현할 때는 template method 패턴을 이용할 수 있다.
- 이는 상속의 개념이 있는 **상위 클래스와 하위 클래스의 구조에서 표현**할 수 있다.
- 일반적으로 상위 클래스(추상 클래스)에는 추상 메서드를 통해 기능의 골격을 제공하고, 하위 클래스(구체 클래스)의 메서드에서는 세부 처리를 구체화한다.
- **상위 클래스에서는 추상적으로 표현하고 그 구체적인 내용은 하위클래스에서 결정되는 디자인 패턴**을 template method 패턴이라고 한다.
- 상속의 개념처럼 template method 패턴도 코드 양을 줄이고 유지보수를 용이하게 만드는 역할을 한다.



### Visitor Pattern

- 각 클래스의 데이터 구조로부터 처리 기능을 분리하여 별도의 visitor 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 하는 것이다.
- visitor pattern을 이용해 **특정 클래스의 데이터 구조와 그 구조 내부를 돌아다니면서 수행하는 특정 작업(로직)을 분리** 할 수 있다.
- **객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때** 많이 사용한다.



### Chain of Responsibility Pattern

- 책임들이 연결되어 있어 내가 책임을 못 질 것 같으면 다음 책임자에게 자동으로 넘어가는 구조이다.
- 소프트웨어 개발에서도 이렇게 자동으로 연결되는 구조로 프로그램을 만들면 매우 유용한데 이 개념을 적용할 수 있는 것이 바로 chain responsibility pattern이다.
- 이 구조는 추상 클래스를 활용하여 설계한다.



### Command Pattern

- 함수 오버로딩(Overloading)과 같은 추상화 개념을 이용한 것이다.
- 단순한 명령어를 추상 클래스(abstract class)와 구체 클래스로 분리하여 단순화한 것으로 끝나지 않고, **명령어에 따른 취소(undo) 기능** 까지도 포함한다.(사용자 입장에서는 해당 명령어를 실행했다가 취소하기도 하기 때문이다.)
- 프로그램의 명령어를 구현할 때는 command 패턴을 활용할 수 있다.



### Mediator Pattern

- 객체지향 설계에서는 많은 객체가 존재하고 이들이 서로 관계를 맺으며 상호작용 한다.
- 이 때 객체의 개수가 너무 많아지면 서로 통신하느라 복잡해져 객체지향에서 가장 중요한 **느슨한 결합** 의 특성을 해칠 수 있다.
- 이를 해결하는 한 가지 방법으로 이를 통제하고 지시할 수 있는 역할을 하는 중재자를 두는 것이다.
- 중재자에게 모든 것을 요구하여 통신의 빈도를 줄여 객체지향의 목표를 달성하게 해주는 것이 바로 mediator 패턴이다.



### State Pattern

- 동일한 동작을 객체 상태에 따라 다르게 처리해야 할 때 사용한다.
- 임베디드 시스템을 포함한 많은 애플리케이션은 이벤트 구동 방식으로 시스템은 이벤트에 의존하여 동작한다. 이런 경우 상태 패턴을 이용하여 디자인한다.
- 상태 패턴을 사용하면 상태와 각 상태 전이를 보다 명시적으로 나타낼 수 있다.
- 특정 상태로 전이되는 것에 각 상태 클래스마다 함수를 만들어주면 되므로 훨씬 유연하고 유지보수가 쉬운 구조를 만들 수 있다.



### Memento Pattern

- undo 기능을 개발할 때 쓸 수 있다.
- 클래스 설계 관점에서 **객체의 정보를 저장할 필요**가 있을 때 적용할 수 있다.



### Interpretor Pattern

- 무언가를 번역하는 데 사용
- 간단한 언어 문법을 정의하고 해석하는데 사용
- 주로 sql 언어나 통신 프로토콜 같은 것을 개발할 때 문법 규칙을 클래스화한 구조를 갖는다.