### GoF 디자인 패턴

1. 생성 패턴
2. 구조 패턴
3. 행위 패턴



### 구조 패턴(Structural pattern)

- 프로그램 내의 자료구조나 인터페이스 구조 등 프로그램의 구조를 설계하는데 많이 활용될 수 있는 패턴이다.
- 클래스나 객체들의 구성(합성)을 통해서 더 큰 구조로 만들 수 있게 해준다.
- 규모가 큰 시스템은 많은 클래스로 구성되어 복잡한 구조를 가지며 이로 인해 수정으로 인한 오류도 많이 발생할 수 있다.
- 이렇게 복잡한 형태의 구조를 갖는 시스템을 개발하기 쉽게 만들어주는 패턴이 바로 이 구조 패턴이다.
- 구조 패턴을 이용하면 새로운 기능을 가진 복합 객체를 효과적으로 작성할 수 있다.



### Composite Pattern

- 사용자가 **단일 객체(ex 파일)** 와 **복합 객체(ex 폴더)** **모두 동일하게 다루도록** 한 것이다.
- 집합 속에 포함될 객체와 집합을 가지고 있는 객체, 이들 모두가 자기 자신과 동일한 타입(메소드와 데이터)의 객체 리스트를 가질 수 있도록 도와준다.
- 컴포지트 패턴을 사용하려면, 기본 클래스와 이를 포함하는 컨테이너 클래스를 구분하지 않고 처리하는 재귀적 합성을 할 수 있다.



### Adapter Pattern

- **기존 클래스를 재사용**할 수 있도록 **중간에서 맞춰주는 역할**을 한다.
- 즉 호환성이 없는 **기존 클래스의 인터페이스를 변환해 재사용**할 수 있도록 해준다.
- 이미 개발된 클래스, 즉 레거시 시스템의 인터페이스를 다른 클래스의 요구에 맞게 인터페이스를 변환해주는 것이다.
- 이미 만들어져있는 클래스를 사용하고 싶지만 인터페이스가 원하는 방식과 일치하지 않을 때, 또는 관련성이 없거나 예측하지 못한 클래스와 협동하는 재사용 가능한 클래스를 생성하고자 할 때 사용된다.
- **클래스 adapter 패턴**은 **상속**을 이용한 것이고, **인스턴스 adapter 패턴**은 **위임**을 이용한다.



### Bridge Pattern

- 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 각자 독립적으로 변형할 수 있게 해준다.
- 구현과 인터페이스(추상회된 부분)을 분리할 수 있고, 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있다.



### Decorator Pattern

- 기존에 구현되어 있는 클래스에 **그때그때 필요한 기능을 추가해나가는 설계 패턴**이다.
- 기능 확장이 필요할 때 상속의 대안으로 사용한다.



### Facade Pattern

- 서브시스템 내부가 복잡하여 클라이언트 코드가 사용하기 힘들 때 사용한다.
- 몇 개의 **클라이언트 클래스와 서브시스템의 클라이언트 사이**에 **facade라는 객체를 세워놓음**으로써 **복잡한 관계를 정리(구조화)**한 것이다.
- 모든 관계가 전면에 세워진 facade 객체를 통해서만 이루어질 수 있게 단순한 인터페이스를 제공(단순한 창구 역할)하는 것이다.
- 서브시스템 내부에서 작동하고 있는 많은 클래스들의 관계나 사용법을 의식하지 않고 facade에서 제공하는 단순화된 하나의 인터페이스만 사용하므로, 클래스 간의 의존 관계가 줄어들고 복합성 또한 낮아지는 효과를 볼 수 있다.



### Flyweight Pattern

- **메모리 사용량을 줄이기** 위한 방법이다.
- 인스턴스를 필요한대로 다 만들어 쓰지 않고, **동일한 것은 가능하면 공유해서 객체 생성을 줄이는 패턴**이다.



### Proxy Pattern(대리인 패턴)

- 일반적으로 프록시는 다른 무언가와 이어지는 인터페이스 역할을 하는 클래스이다.
- 프록시는 자신이 대변하는 객체와 그 객체에 접근하고자 하는 클라이언트 사이에서 여러 방식으로 작업을 처리한다.